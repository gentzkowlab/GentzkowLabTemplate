{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GentzkowLabTemplate Docs!","text":"<p>This template is designed to provide a simple, extendable, and reproducible framework that allows teams of researchers to collaborate using multiple software tools (e.g., Python, R, Stata, Latex, Julia) across multiple  platforms (Linux/MacOS, Windows).</p> <p>To learn more about the principles behind the template, see Code and Data for the Social Sciences: A Practitioner's Guide, by Matthew Gentzkow and Jesse Shapiro.</p> <p>The template is distributed under the MIT license. </p>"},{"location":"faq/","title":"FAQ","text":"<p>TBD</p>"},{"location":"about/how_to/","title":"How to use this site","text":""},{"location":"about/how_to/#search","title":"Search","text":"<p>To search the guide, type S, F or /, or click the search box in the top bar.</p>"},{"location":"about/how_to/#color-mode","title":"Color mode","text":"<p>Click the eye icon ( or ) in the top bar to toggle between light and dark mode.</p>"},{"location":"template/examples/","title":"Examples","text":"<p>The directory <code>/examples/</code> contains example scripts that illustrate how to use the template with tools such as R, Python, Stata, Julia, Matlab, LaTeX, and Lyx. The <code>README.md</code> files in these directories provide additional detail on how to use the respective tool with the template and requirements for running the example scripts.</p> <p>The general steps to set up the template to run the example scripts are:</p> <ol> <li>Make sure the appropriate software (e.g., Python, R) is installed along with any required libraries/packages</li> <li>Locate the module(s) where you will place the script(s)</li> <li>Copy the script(s) to the module(s)' <code>source</code> directory</li> <li>Update the module(s)' <code>make.sh</code> script(s) as follows<ul> <li>Uncomment the line beginning <code>#source \"${REPO_ROOT}/...</code> that loads the relevant <code>run_XXX</code> shell command</li> <li>Uncomment the line beginning <code># run_...</code> to execute the relevant <code>run_XXX</code> shell command, and replace the placeholder script name with the name of your script(s)</li> </ul> </li> <li>Update the module(s)' <code>get_inputs.sh</code> script(s) to create links for any needed inputs in the <code>/input/</code> directory</li> <li>Run the module's <code>make.sh</code> script to confirm that the example script executes correctly</li> </ol> <p>The <code>local_env.sh</code> settings file at the top level of the repository (created when you run <code>setup.sh</code> if it didn't exist before) defines the name of executables for software tools like Python and R. If the name of your local executable is different from the default name you can change it in this file. All such tools you intend to use must be callable from the command line (i.e., must be added to the appropriate system path). In this file, you can also list paths to any external input paths.</p>"},{"location":"template/getting_started/","title":"Getting started","text":""},{"location":"template/getting_started/#creating-a-repository","title":"Creating a repository","text":"<p>To create your own repository from the template, navigate to its GitHub page and click Use this template. See GitHub's documentation for more details.</p>"},{"location":"template/getting_started/#opening-an-existing-project","title":"Opening an existing project","text":"<p>Follow these steps:</p> <ol> <li> <p>Clone the repository and move into its directory:</p> <pre><code>git clone https://github.com/MyRepoName\ncd MyRepoName\n</code></pre> </li> <li> <p>Run the <code>setup.sh</code> script to create the local settings file <code>local_env.sh</code>, and verify that local executables are correctly installed:</p> <pre><code>bash setup.sh\n</code></pre> </li> <li> <p>Run the <code>run_all.sh</code> script to check that the template runs without error:</p> <pre><code>bash run_all.sh\n</code></pre> </li> </ol>"},{"location":"template/repository_organization/","title":"Repository organization","text":""},{"location":"template/repository_organization/#overview","title":"Overview","text":"<ul> <li><code>README.txt</code>: The repository's readme file.</li> <li><code>LICENSE.txt</code>: The template's MIT License.</li> <li><code>run_all.sh</code>: Runs the repository from beginning to end.</li> <li><code>setup.sh</code>: Meant to be run when you first clone the template (or first clone a repo based on the template). It creates local_env.sh, runs get_inputs.sh in each module, and runs make_externals.sh.</li> <li><code>local_env.sh</code>: Stores settings and paths specific to a user's local environment. This file is not committed to Git. If it doesn't exist it is created when you run <code>lib/shell/check_setup.sh</code> or <code>setup.sh</code>\"</li> <li><code>/lib/</code>: Contains code libraries/packages that are used across multiple parts of the repository.</li> <li><code>/examples/</code>: Examples that illustrate how to use the template with specific software tools.</li> <li><code>/0_raw/</code>: Contains raw data, images, etc. that are inputs to the code downstream and are committed to the repository.</li> <li><code>/1_data/</code>: Cleans and wrangles the data.</li> <li><code>/2_analysis/</code>: Runs the analysis.</li> <li><code>/3_slides/</code>: Makes the slides.</li> <li><code>/4_paper/</code>: Makes the paper.</li> </ul>"},{"location":"template/repository_organization/#modules","title":"Modules","text":"<p>The template is organized into modules. A module is a subdirectory with a <code>make.sh</code> script at its root, a <code>/source/</code> subdirectory, and an <code>/output/</code> subdirectory. Each module is a self-contained unit that runs code in <code>/source/</code> to produce output in <code>/output/</code>. If a module uses inputs beyond the code itself (e.g., data stored elsewhere in the repository and/or externally), these are placed in an <code>/input/</code> subdirectory with copies (and/or symlinks) of the relevant inputs.</p> <p>Out of the box, the template contains 4 modules, <code>1_data</code>, <code>2_analysis</code>, <code>3_slides</code>, and <code>4_paper</code>. The subdirectory <code>0_raw</code> is not a module because it does not contain code -- it is only used for storing static data.</p> <p>Organizing a repository into modules has several advantages:</p> <ul> <li>The high-level structure of the repository is clear to the user</li> <li>Each module is a self-contained unit that a user can understand without looking at other modules</li> <li>Any given module can be run from beginning to end in a reasonable amount of time</li> <li>Well-organized modules produce clean commit histories</li> </ul> <p>The default structure of the template is just an example. You should define and organize modules in the way that makes sense for your projet. You can add additional modules at the top level of the repository -- for example,</p> <ul> <li><code>1_data</code></li> <li><code>2_descriptive_analysis</code></li> <li><code>3_structural_estimation</code></li> <li><code>4_slides</code></li> <li><code>5_paper</code></li> </ul> <p>Each of these subdirectories should have its own <code>make.sh</code>, <code>/source/</code>, and <code>/output/</code>.</p> <p>You can also subdivide top-level subdirectories into multiple modules -- for example,</p> <ul> <li><code>1_data</code><ul> <li><code>1_survey_data</code></li> <li><code>2_geo_data</code></li> <li><code>3_admin_data</code></li> </ul> </li> </ul> <p>In this case, each of <code>1_survey_data</code>, <code>2_geo_data</code>, and <code>3_admin_data</code> should have their own <code>make.sh</code>, <code>/source/</code>, and <code>/output/</code>. The top-level <code>1_data</code> directory should not contain anything other than the subdirectories.</p> <p>Here are some key principles for organizing modules:</p> <ul> <li>Use numerical prefixes like <code>1_xxx</code>, <code>2_xxx</code>, etc. to make clear the order in which modules should be run.</li> <li>Each module should have a clear scope and purpose that a user can easily guess from its name.</li> <li>Modules should be small enough that the <code>make.sh</code> script can be run in a reasonable amount of time. If a module takes hours or days to run, it is often a good idea to break it up into multiple smaller modules.</li> <li>Very slow steps should be isolated in separate modules. For example, if there is an estimation step that takes many days to run, this should be in a separate module from other steps like descriptive analysis, formatting tables and figures, etc.</li> <li>Steps that are modified and re-run frequently should be isolated in separate modules. For example, it often makes sense to separate formatting tables and figures from the analysis code that produces the inputs to the tables and figures.</li> <li>Modules should be defined to keep the dependency tree of the repository as simple and untangled as possible. For example, it is often a good sign if all downstream analysis modules call inputs from one or a small number of upstream data-building modules.</li> </ul>"},{"location":"template/repository_organization/#make-scripts","title":"Make scripts","text":"<p>The script <code>make.sh</code> runs a given module from beginning to end. More specifically, it:</p> <ul> <li>Loads local settings and paths from <code>local_env.sh</code></li> <li>Loads shell commands from <code>/lib/shell/</code></li> <li>Clears the <code>/output/</code> directory</li> <li>Populates the <code>/input/</code> directory</li> <li>Runs the scripts in <code>/source/</code> with a sequence of command-line calls </li> <li>Logs everything in <code>/output/make.log</code></li> </ul> <p>The calls to the individual scripts are governed by a set of shell commands named <code>run_python</code>,  <code>run_R</code>, etc. that are defined in <code>lib/shell/</code>. These are very simple wrappers that issue the appropriate command line calls to run a given script. You could replace these  with direct command-line calls -- for example, you could replace the line</p> <pre><code>run_python wrangle_data.py \"${LOGFILE}\" || exit 1\n</code></pre> <p>in <code>1_data/make.sh</code> with</p> <pre><code>python3 wrangle_data.py &gt;&gt; \"${LOGFILE}\" || exit 1\n</code></pre> <p>The advantages of using the wrapper commands include:</p> <ul> <li>They use executable names defined by <code>local_env.sh</code>, so that the code can work across machines with different local configurations</li> <li>They clean up LaTeX auxiliary files</li> <li>They copy LaTeX output files to the <code>output</code> directory, whereas <code>pdflatex</code> places output in the same directory as the code by default</li> <li>They copy default Stata logs into <code>/output/make.log</code></li> <li>They handle differences in Stata command line syntax across operating systems</li> <li>They handle cases where scripts terminate with errors in a friendly way</li> </ul>"},{"location":"template/repository_organization/#inputs-and-outputs","title":"Inputs and outputs","text":"<p>Code in a module's <code>/source/</code> directory should only call inputs from the module's <code>/input/</code> directory, or, in the case of inputs that are produced within the module itself, from <code>/output/</code> or <code>/temp/</code> (a temporary directory that will be ignored by Git). Code should never reference files elsewhere in the repository, or files external to the repository, directly. </p> <p>The module's <code>input</code> directory should be populated by the module's <code>make.sh</code> script which calls <code>get_inputs.sh</code>. It should never be modified directly by the user.</p> <p>All output should be placed the module's <code>/output/</code> directory. Files that cannot be committed to Git (e.g. because they are too large) should be placed in <code>/output_local/</code> instead, which is not committed to Git by default.</p> <p>Benefits of following these rules include:</p> <ul> <li>The input-output structure of each module is transparent to the user</li> <li>Modules are self-contained and can be placed anywhere within the repository's directory structure</li> <li><code>make.sh</code> can log the state of the inputs at the time when the module was run</li> <li><code>make.sh</code> can guarantee that all contents of <code>/output/</code> were produced by a single run of the code</li> <li>If the location of an input file changes, this can be updated once in <code>get_inputs.sh</code> (for an input in the repository) or <code>local_env.sh</code> (for an external input); there is no need to change file paths in scripts individually.</li> <li>It is easy to produce a graph of the input-output flow of the repository as a whole</li> </ul>"},{"location":"template/repository_organization/#external-dependencies","title":"External dependencies","text":"<p>In some cases, a repository may depend on data files or other inputs that are external to the repository. The most common case is data files that cannot be committed to Git (either because they are too large or because their license does not permit it). In this case, the local paths to these external dependencies should be defined as shell variables in <code>local_env.sh</code>. The <code>lib/shell/make_externals.sh</code> script should then be be run to create symlinks to the external resources within the root of the repo.</p> <p>The comments in <code>local_env.sh</code> should provide detail on the nature of the external files, their provenance, and how a user can locate them. If the external files are raw data, they should be documented with a <code>README</code> just like the files in <code>0_raw</code>. If the external files are produced in a different repository, they should be called in a way that records the repository and revision that produced them.</p>"},{"location":"template/requirements/","title":"Requirements","text":"<p>The template requires that you have the ability to run Linux/MacOS shell (<code>.sh</code>) scripts. Windows users can run these scripts using a Windows Bash emulator such as GitBash.</p> <p>As an optional feature, we also recommend that you have Git LFS installed. This allows Git to store large binary files (including PDFs) efficiently. You can set up Git LFS following the instructions here.</p> <p>We also recommend setting up a project Google Drive to organize files related to the project. You can find a template structure for the Drive along with setup instructions here.</p>"}]}